Notations for shell syntax:

CHAR =  "a"|"b"|"c"|"d"|"e"|"f"|"g"|"h"|"i"|"j"|"k"|"l"|"m"|"n"|"o"|"p"|"q"|"r"|"s"|"t"|"u"|"v"|"w"|"x"|"y"|"z"
       |"A"|"B"|"C"|"D"|"E"|"F"|"G"|"H"|"I"|"J"|"K"|"L"|"M"|"N"|"O"|"P"|"Q"|"R"|"S"|"T"|"U"|"V"|"W"|"X"|"Y"|"Z"
       |"!"|"%"|"+"|","|"-"|"."|"/"|":"|"@"|"^"|"_"
       |DIGIT;

DIGIT = 0|1|2|3|4|5|6|7|8|9;

WORD = CHAR , { CHAR };

IO_NUMBER = DIGIT , { DIGIT };

IO_REDIRECTION = [ IO_NUMBER ] ,  ( "<" , WORD | "<&" , IO_NUMBER | "<>" , WORD | ">" , WORD | ">&" , IO_NUMBER | ">>" , WORD | ">|" , WORD );

SIMPLE_COMMAND = WORD , { WORD };

COMMAND = ( SIMPLE_COMMAND | SUBSHELL_COMMAND ) , { IO_REDIRECTION };

SUBSHELL_COMMAND = "(" , COMMAND_SEQUENCE , ")";

PIPELINES = COMMAND , { "|" , COMMAND };

LOGICALS = PIPELINES , { ( "&&" | "||" ) , PIPELINES };

COMMAND_SEQUENCE = LOGICALS , { ";" , LOGICALS };

The start symbol is COMMAND_SEQUENCE.

I wrote down the syntax for the shell as above before implementing the parser so that:
_ I can have a clear understanding of what is expected from the syntax, such as operator precedence or expected tokens. For example, since PIPELINES is parsed before LOGICALS, this makes clear that "|" has higher precedence that "&&" or "||".
_ I can validate and make sure the syntax covers most common cases.
_ I can change the syntax easily to cover unexpected edge cases. In such case, changing the parser is also easy because its implementation mirrors the syntax.

I haven't found a decent solution to represent the syntax for linebreaks, semicolons, and COMMAND_SEQUENCE. As the result, the logic for parsing COMMAND_SEQUENCE is a bit clunky (need 3 tokens lookup ahead) and could fail to reject a few syntactically invalid edge cases.

My implementation includes 2 things: a scanner and a parser. The scanner reads the file and produces a stream of tokens. The parser reads this stream and builds the command stream based on the syntax above.
